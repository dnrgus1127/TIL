[인터프리터 언어](https://github.com/dnrgus1127/TIL/blob/main/frontend/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%20%EC%96%B8%EC%96%B4%EC%99%80%20%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%20%EC%96%B8%EC%96%B4%EC%9D%98%20%EC%B0%A8%EC%9D%B4-%EC%9E%AC%EC%A0%95%EB%A6%AC.md)
에서 정리했듯이 자바스크립트는 코드를 한줄씩 순차적으로 실행하는 인터프리터 언어다.

```js
console.log(name);

var name = "jung";
```


그 말대로라면 순차적으로 실행하기 때문에 위 코드에서 `console.log(name)`이 실행될 때는 참조 에러가 발생할 것 같지만 실제로는 그렇지 않고, **undefined**가 출력되게 된다.

## 변수의 선언과 값의 할당 시점

이런 현상이 발생하는 이유는 자바스크립트의 특징에 있다.

### 변수 선언

자바스크립트의 변수 선언은 **소스코드가 한줄씩 해석되고 실행되는 시점(런타임)** 이 아닌 **소스 코드 평가** 시점에 실행된다.

> 소스 코드의 평가 과정
소스 코드 실행(런타임)을 위해서 필요한 준비 단계로 이 시점에서 변수 선언과 같은 모든 선언문 (변수, 함수 선언문)을 소스 코드 내에서 찾아 먼저 실행한다.

이처럼 변수 선언이 코드의 가장 상단으로 옮겨진 것처럼 실행되는 자바스크립트의 특징을 **변수 호이스팅** 이라고 한다.

> 변수 뿐만이 아니라 var, let, const , function, class와 같은 모든 식별자들은 모두 런타임 이전에 실행된다.(호이스팅 된다.).


### 값의 할당
```js
var name = "jung";
```
그럼 이처럼 변수의 선언과 값의 할당을 동시에 하는 경우 변수의 선언과 할당이 같이 호이스팅 되어 동작하는 걸까?

그렇지 않다.

사실 위 코드는 아래 코드를 단축표현하는 방식일 뿐이다.
```js
var name;
name = "jung";
```
그렇기 때문에 실제로는 변수 선언과 값의 할당이 각각 실행되게 되고, 변수 선언은 **런타임 이전** 값의 할당은 **런타임**에 발생하게 된다.



```js
console.log(name); // console : undefined

var name = "jung";
```
그렇기 때문에 이 코드에서 `console.log(name)`는 호이스팅에 의해서 참조 에러는 발생하지 않지만, 아직 값의 할당은 실행되지 않았기 때문에 name에 초기화된 undefined가 출력되게 된다.


# 함수의 호이스팅
함수의 선언문도 다른 선언문과 마찬가지로 런타임 이전에 자바스크립트 엔진에 의해서 먼저 실행된다. 

하지만 함수의 호이스팅과 변수의 호이스팅에는 약간의 차이가 존재한다.

var 키워드를 이용한 변수의 호이스팅은 변수 선언만 끌어올려지고 undefined 값으로 초기화되어서 변수 선언문 이전에 변수를 참조하면 undefined값만 얻을 수 있지만, 함수는 undefined가 아닌 함수 객체로 초기화되기 때문에 함수 선언문 이전 시점에서 호출이 가능하다.

> 하지만 이는 함수를 function 키워드를 이용해 정의했을 때만 가능하다. 하지만 함수 선언문이 아닌 함수 표현식으로 함수를 정의하게 되면 함수 호이스팅이 아닌 변수 호이스팅이 발생해서 표현식 이전에 함수를 참조할 수 없다.

```js
function declarationFunc() { // 함수 선언문, 선언문 이전에 함수를 호출할 수 있다.
    return "함수 선언문으로 작성된 함수";
}

var expression = function () { // 함수 표현식, 표현식 이전에 함수를 호출하면 타입 에러가 발생한다.
    return "함수 표현식으로 작성된 함수";
}
```


# let과 const의 호이스팅
ES6에 도입된 변수 선언 키워드인 let과 const는 호이스팅이 발생하지 않는 **것처럼** 동작한다.

> 나는 let과 const는 호이스팅이 발생하지 않는 다는 것으로 알고 있었는데 정확히는 호이스팅은 발생하지만 변수 호이스팅이 발생하지 않는 것처럼 동작할 뿐이였다.

let과 const도 var처럼 변수의 호이스팅은 발생하여 변수의 선언이 먼저 실행되나,
변수의 초기화는 변수의 값 할당 단계에서 실행되기 때문에 참조 에러가 발생한다.

- var은 변수의 선언과 undefined로의 초기화가 런타임 이전에 실행된다.
- 하지만 let과 const는 변수의 선언은 런타임 이전에 실행되나 변수의 undefined 할당은 런타임 시점의 값 할당 시점에 실행된다.



# 정리

자바스크립트의 **호이스팅**이란 변수나 함수의 선언문이 런타임 이전에 먼저 실행되는 것으로 변수나 함수가 선언되기 전에 참조할 수 있는 것을 말한다.
let과 const의 경우 호이스팅이 발생하긴 하나 함수의 undefined로의 초기화는 런타임에 변수의 선언문에 도달했을 때 값의 할당 직전에 초기화되기 때문에 변수 선언문 이전에서 **일시적 사각지대**가 발생하여 변수를 참조할 수 없다.
