
# JWT

JSON Web Token(이하 JWT)는 JSON 정보를 신뢰할 수 있게 전송하기 위한 방식 중 하나다.

JWT는 디지털서명을 기반으로 해당 정보의 **무결성**과 데이터를 전송한 발신자에 대한 **인증**을 해결함으로서 데이터의 신뢰성을 높이는 방식이다.

> HMAC 기반의 대칭 키 혹은 RSA나 ECDSA 기반의 공개 키 방식으로 서명되어 사용된다.

> 여기서 인증이란 해당 데이터를 보낸 송신자가 A가 맞다는 것을 확인하는 것이다.


## JWT가 유용한 경우

#### 권한 부여
사용자가 로그인하면 후속 요청에 발급된 JWT를 전송함으로서 사용자가 추후 로그인 권한이 필요한 작업을 진행할 때 이 JWT를 이용하여 인증이 필요한 페이지나 서비스, 리소스 등에 접근할 수 있게 된다. 주로 JWT는 권한 부여를 위해서 많이 사용하게 된다.

#### 정보 교환
JWT는 디지털 서명을 기반으로 교환되는 정보에 대한 변조 여부나 발신자를 확인하여 정보의 신뢰성을 높이기 때문에 해당 데이터를 안전한 방식으로 교환하는데 사용된다.

> 여기서 안전한 방식은 중간자가 정보를 읽지 못하게 하는 것이 아니라, 변조하지 못하게 하는 것을 말한다.


## JWT의 구조
JWT 토큰은 `.` 으로 구분된 3가지 영역으로 구성되어 있다.

- Hedaer 헤더
- Payload 페이로드
- Signature 시그니처

### 헤더
첫 번쨰 영역인 헤더에는 일반적으로 토큰의 종류 (JWT)와 서명 알고리즘의 종류에 대해서 적혀 있다.

```json
{
  "alg" : "HS256", // HMAC, SHA256, RSA와 같은 서명 알고리즘
  "typ" : "JWT" // 토큰에 대한 정보
}
```

이렇게 완성된 헤더는 base64Url 인코딩을 통해서 JWT의 첫번째 파트를 형성한다.

```json
xxxxx.
// 인코딩된 헤더.
```

### 페이로드
두 번째 영역인 페이로드에는 JWT가 전달할 데이터가 정의되어 있다.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
페이로드는 클레임이라는 작은 데이터 조각으로 나뉘고, 이들은 Registred, Public, Private 세 분류로 나뉘어 진다. 
이 내용에 관심이 있다면 해당 JWT 소개를 읽으면 파악이 가능한다. [Jwt.io](https://jwt.io/introduction)

페이로드도 헤더와 마찬가지로 Base64Url 인코딩을 거쳐 JWT의 두번째 파트를 형성한다.

```json
xxxxxx.yyyyyy.
// 인코딩된 헤더.인코딩된 페이로드
```

### 서명
서명 파트는 JWT토큰의 무결성 검증과 인증과 관련된 디지털 서명과 관련된 내용이 담겨 있다.

서명 부분을 만들기 위해서 인코딩된 헤더와 인코딩된 페이로드를 헤더에 지정된 알고리즘을 이용해 비밀 키를 이용하여 서명한다.

아래는 HMAC과 SHA256알고리즘을 사용하여 서명을 하는 예시다.

```json
HMACSHA256( // 헤더에 적힌 알고리즘
  base64UrlEncode(header) + "." + //인코딩된 헤더
  base64UrlEncode(payload), // 인코딩된 페이로드
  secret) // 비밀 키
```

이 서명을 통해 JWT의 페이로드가 변경되진 않았는지, 송신자가 내가 알고있는 송신자가 맞는지 검증할 수 있다.


```json
xxxxxx.yyyyyy.zzzzzz
// 인코딩된 헤더.인코딩된 페이로드.서명
```


### 완성된 JWT
즉 JWT는 인코딩되어있는 헤더 + 인코딩된 페이로드 + 이를 바탕으로 생성한 서명의 구조를 가진다.

```json
eyJhbGciOiJIUzI1NiIsInR5cCI6I.eyJzdWiOItlxMjM0Nty30drDODdkNQPX134kd1d04cdpq.4pcPyMd09olPSyXnrXcjt
//인코딩된 헤더.인코딩된 페이로드.서명
```

## JWT를 이용한 권한 부여 시나리오
이렇게 완성된 JWT가 어떻게 쓰이는지를 알기 위해서, JWT를 이용한 사용자 인증에 대한 시나리오를 살펴보자.


1. 사용자가 서비스에 로그인 요청을 한다.
2. 로그인이 성공했다면 서버는 헤더와 페이로드를 base64로 인코딩하고, 이 내용을 서버의 개인 키로 암호화하여 디지털 서명을 작성한다. 
3. 인코딩된 헤더와 페이로드, 디지털 서명을 합쳐서 JWT토큰을 생성하고 응답 헤더에 담아서 클라이언트에게 전달한다.
4. 클라이언트는 JWT를 해석하여 로컬 스토리지 등에 저장한다.
  - JWT의 헤더, 페이로드를 base64디코딩하고, 디지털 서명을 서버의 공개 키로 복호화 해서 해당 JWT가 무결한지 확인한다. 
5. 사용자가 다시 인증이 필요한 리소스에 접근할 때 요청 헤더에 JWT 토큰을 포함시켜 전송한다.
6. 서버는 JWT의 서명을 자신의 개인 키로 복호화하여 JWT 변조 여부를 파악하고, 변조되지 않았다면 페이로드를 읽어서 인증에 대한 처리를 한다.
7. 토큰이 만료되지 않았다면 인증이 필요한 리소스를 응답하고, 만료되었다면 인증 만료 오류를 클라이언트에게 전달한다.


## JWT의 장단점

### JWT의 장점
- 인증에 필요한 정보가 JWT 속에 있기 때문에 별도의 인증 관련 데이터를 저장할 필요가 없다.
- 적은 용량을 가져 트래픽에 대한 부담이 적어진다.
- URL 파라미터나 헤더로 사용할 수 있다.
- JWT는 독립적이다.

### JWT의 단점
- 토큰 자체에 정보가 담겨 있기 때문에 보안적으로 중요한 정보를 담을 수 없다.
   - 암호 알고리즘을 이용해서 서명을 작성할 뿐, 실제 페이로드는 암호화 되지 않기 때문에 정보는 공개되어있다고 가정해야 한다.
- 정보의 양이 많아질수록 토큰의 길이가 늘어나기 때문에 많은 정보를 담을 수 없다.
- JWT는 Stateless이기 때문에 한번 만들어진 토큰을 강제로 폐기할 수 없다. 토큰이 탈취되는경우 제어하기 힘들기 때문에 토큰의 만료 시간을 적용해야 한다.


## JWT는 어디에 저장해야 안전할까?
JWT는 클라이언트 측에 저장하고 이용해야한다. 

그럼 클라이언트의 어디에 저장해야 안전할까?

우선 클라이언트에 jwt를 저장하기 위해서 **localStorage**와 **Cookie**중 고려를 해야 한다.

두 방법을 웹 사이트 공격에 사용하는 `XSS(크로스 사이트 스크립팅)` 와 `CSRF(크로스 사이트 요청 위조)`를 기준으로 비교를 해보겠다.

### XSS 관점에서
우선 크로스 사이트 스크립팅 공격에는 쿠키가 로컬 스토리지보다 유리하다.
XSS는 상대의 브라우저에서 공격자의 JS가 실행되게 하는 공격 방식인데 로컬 스토리지는 JS를 이용해서 자유롭게 데이터를 가져올 수 있지만, 쿠키는 httpOnly 옵션을 이용한다면 js에서 쿠키의 접근을 차단할 수 있다.

> 물론 쿠키도 js를 이용해 request를 보내게 되면 이에 쿠키 내용이 실리기 때문에 안전하다고 할순 없다.

### CSRF 관점에서
CSRF관점에서는 로컬 스토리지가 유리하다. CSRF는 사용자가 악의적인 URI 등을 클릭함으로서 의도하지 않은 HTTP 요청을 보내게 하는 공격인데, 이 떄 쿠키는 자동으로 요청 헤더에 포함되게 된다.


이렇게 보면 두 방식 다 장점과 약점이 있고, 실제로도 지지하는 입장이 갈린다고 한다.


## 그럼 어떻게 해야 안전하게 JWT를 사용할 수 있을까?
JWT의 가장 큰 약점은 탈취다. JWT가 탈취당한다면 서버 입장에서는 해당 토큰을 이용한 요청이 진짜 사용자가 보낸 것인지 공격자가 보낸 것인지 확인할 방법이 없다.

그래서 탈취 당한 JWT에 유효 기간을 두는 방법을 선택했다.

### JWT의 유효 기간
그렇지만 한가지 딜레마가 생긴다. 
- 유효기간을 짧게 두자니 정상적인 사용자가 로그인을 너무 자주 해야해서 UX 측면에서 좋지 않다.
- 유효기간을 길게 두면 보안상 탈취 위험이 너무 크다.

이를 해결하기 위해서 유효기간이 다른 2개의 JWT 토큰을 사용하는 방식이 있다.

## Access Token과 Refresh Token
유효기간이 짧은 Access Token과, 유효기간이 긴 Refresh Token을 이용하는 방식으로,

평소의 통신에는 Access Toekn을 이용해서 만료 기간을 짧게 두고,
Access Token이 만료된다면 Refresh Token을 이용해서 Access Token을 재발급 받는 방식이다.

즉, **탈취당할 위험이 큰 토큰(Access Token)**의 유효기간을 짧게 두고 **탈취당할 위험이 적은 토큰(Refresh Token)**의 유효기간을 길게 두는 방식이다.

> 탈취당할 위험도는 통신에 사용되는 횟수 정도로 생각하면 될것 같다. 

#### Refresh Token이 탈취된다면? - Refresh Token Rotation
Refresh Token이 통신 빈도가 적어서 탈취될 확률이 적긴 하지만 아예 없다고 할 수는 없다.

그래서 최근에는 Refresh Token을 이용해서 Access Token을 재요청 할 때마다 새로운 Refresh Token을 발급하는 **Refresh Token Rotation** 방식을 사용하여 위험도를 줄인다고 한다.


---

# 결론
- JWT는 사용자 인증과 관련된 정보를 디지털 서명을 이용하여 공유하는 방식이다.
- JWT의 페이로드는 암호화되지 않기 때문에 중요한 정보는 담지 않아야 한다.
- JWT는 탈취에 취약하기 때문에 Aceess Token과 Refresh토큰을 이용하여 이를 완화한다.

# 여담
실제 면접에서 JWT관련 질문을 받기도 했고, API 요청을 하면서 JWT를 사용해 통신을 한 경험이 있었다. 
하지만 정확히 JWT에 대한 이해도는 부족하다고 면접 때 확실히 느꼇고 정리를 해봤다.

JWT는 인증에 필요한 정보를 암호화한다고 잘못 알고 있었고, 디지털 서명을 통해 신뢰성과 무결성을 보장하는 방식이라는 것을 이해할 수 있었다.

전공을 들을때 디지털 서명에 대해서 배웠기 때문에 이해하는데는 큰 어려움이 없었다.

# 참고
- [jwt.io](https://jwt.io/introduction)
- [JWT이란?](https://www.devkuma.com/docs/jwt/)
