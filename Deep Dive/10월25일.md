
# 타이머
## setTimeout/clearTimeOut
## setInterval/clearInterval
## debounce/throttle
> 디바운스는 React로 프로젝트를 진행하던 중에 무한 스크롤 구현을 위해 사용한적이 있었는데, 관련된 책을 다시 읽으니 금방 이해가 됐다.

---

# 비동기 프로그래밍
- 자바스크립트는 싱글스레드, 브라우저의 태스크 큐는 멀티 스레드
## 태스크 큐와 이벤트 루프
> #### 콜 스택
> 실행 컨텍스트 스택, 함수가 호출되면 순차적으로 콜 스택에 푸시되어 실핸된다.
### 태스크 큐
비동기 함수에게 전달되는 콜백 함수, 이벤트 핸들러 등이 일시적으로 보관되는 장소
### 이벤트 루프
브라우저에 내장되어 있는 기능으로 콜 스택이 비어있고, 태스크 큐에 실행을 기다리는 함수가 남아 있는 경우 이벤트루프가 콜스택에 태스크 큐에 대기중인 함수들을 콜 스택으로 이동시킨다.

> 태스크 큐와 이벤트 루프를 공부하면서 왜 JS의 타이머가 타이머의 인자로 전달된 시간 이후에 실행되는 것은 보장하지만, 정확히 그 시간 뒤에 실행될지 보장하지 못하는 것에 대해 이해할 수 있었다.
> 전부터 궁금하던 부분인데 해결이 되었다.
  

# Ajax 
Ajax :  자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고 서버가 응답한 데이터를 수신하여 웹 페이지를 동적으로 갱신하는 방식.

## XMLHttpRequest
- 자바스크립트를 이용하여 HTTP 요청을 전송하기 위해 사용하는 객체.
- open, setRequestHeader, sender 메서드를 이용하여 HTTP 요청을 보낸다
- GET 요청은 쿼리스트링으로 ,POST 요청의 경우 sender의 인자로 데이터를 전달할 수 있다.
- 비동기 요청의 응답은 XMLHttpRequest 객체의 이벤트 핸들러 프로퍼티를 이용하여 처리할 수 있다.
  
# REST API
## REST 
HTTP의 장점을 최대한 활요할 수 있는 아키텍처, 이를 만족한 서비스를 Restful하다고 표현한다.
## REAT API 구성
- 자원, 행위, 표현 3가지 요소로 구성된다.
- URI는 리소스를 표현하는데 중점을 둬야 하기 때문에 동사보다 명사를 사용한다. 행위는 HTTP Method를 이용한다.
> 블로그 프로젝트를 진행할 떄 get, set 등을 uri에 사용했던 것으로 기억한다. 반성하자.

# 프로미스
프로미스는 비동기 처리중 기존 콜백 패턴의 단점인 콜백 지옥을 보완하여 명확하게 사용할 수 있다는 장점이 있다.
- pending, fulfilled, rejected 상태를 가진다. (비동기 수행전, 수행성공, 수행실패)
## resolve, reject
프로미스를 생성자 함수로 생성할 떄 인수로 전달하는 함수들로, 비동기 처리 성공시 resolve , 실패 시 reject를 호출한다.

## 프로미스 후속 처리 메서드 then,catch, finally 
비동기 처리가 완료된 후 resolve,reject의 결과로 전달된 값을 조작하기 위한 메서드
- 후속 처리 메서드는 반환으로 프로미스를 반환하기 떄문에 메소드 체인으로 호출이 가능하다.
### then
### catch
### finally
- 한개의 콜백함수를 인수로 전달 받으며, 프로미스 fulfilled, rejected 여부에 상관없이 실행되는 메서드.
> React 프로젝트를 진행하며 then과 catch는 많이 사용해 봤으나 finally라는 후속 처리 메서드가 있다는 사실을 처음 알게 되었다.

## 프로미스 정적 메서드 all, race
### all
- 프로미스를 요소로 갖는 이터러블을 인수로 전달받아 병렬적으로 실행하여, 모두 완료된 후 결과도 배열로 반환
### rece
- all과의 차이점은 가장 먼저 완료된 하나의 프로미스에 대해서만 반환한다.

## 마이크로테스크 큐
프로미스의 후속 처리 메서드는 태스크 큐가 아닌 마이크로 태스크 큐에 저장되며, 이는 태스크 큐보다 우선순위를 가지고 콜 스택에 전달된다.




## fetch와의 
> fetch API만 사용해 봤었는데 XMLHttpRequest객체를 이해하게 되면서 fetch의 내부적인 동작을 이해하는데 도움이 되었다.
