# 목차

- [타입스크립트와 자바스크립트의 관계 이해하기](#1-타입스크립트와-자바스크립트의-관계-이해하기)
- [타입스크립트 설정(Config) 이해하기](#2-타입스크립트-설정config-이해하기)
  - [자주 사용되는 설정값](#자주-사용되는-설정값)
- [코드 생성과 타입이 관계 없음을 이해하기](#3-코드-생성과-타입이-관계-없음을-이해하기)
  - [타입스크립트가 할 수 있는 일과 없는 일](#타입스크립트가-할-수-있는-일과-없는-일)

# 1. 타입스크립트와 자바스크립트의 관계 이해하기

**타입스크립트는 자바스크립트의 상위집합(Superset)이다.**

타입스크립트의 목표는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. (정적 타입 시스템)

- 프로그램에 오류가 발생하지 않더라도, 코드가 의도치 않은 오류가 발생할 위험이 있다면 타입 체커는 오류를 표시한다.

# 2. 타입스크립트 설정(Config) 이해하기

타입스크립트의 설정은 커맨드 라인 또는 **tsconfig.json** 설정 파일을 통해서 사용할 수 있다.

```bash
tsx --noImplicitAny program.ts
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "noImplicitAny" : true;
  }
}
```

## 자주 사용되는 설정값

### noImplicitAny (암시적 any 타입 금지)

변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다. 이 설정이 꺼져있다면 타입을 지정해주지 않은 경우 암묵적으로 any 타입이 추론된다.

> any 타입은 유용하지만 매우 주의해서 사용해야 한다. any타입을 남발하면 타입 체커는 무력해진다.

> 자바스크립트로 되어있는 기존 프로젝트를 타입스크립트로 마이그레이션 하는 상황에서 해당 옵션을 해제하고 사용한다.

### strictNullChecks

null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.

```jsx
const x: number = null;
// strictNullChecks 해제 시 오류가 발생하지 않는다.
// strictNullChecks 에서는 null 형식은 number에 할당할 수 없다는 에러가 발생한다.
```

> 이 설정 없이 개발하게 된다면 "undefined는 객체가 아닙니다"라는 런타임 오류가 자주 발생할 수 있다고 한다.

# 3. 코드 생성과 타입이 관계 없음을 이해하기

타입스크립트는

- 최신 타입/자바스크립트를 브라우저에서 동작할수 있도록 트랜스파일링 한다.
- 코드의 타입 오류를 체크한다.

위 두가지는 완벽히 독립적이다.

타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않는다.

## 타입스크립트가 할 수 있는 일과 없는 일

### 타입 오류가 있는 코드도 컴파일이 가능하다.

C나 자바같이 컴파일과 타입 체크가 동시에 이루어지는 언어에서는 타입오류가 있다면 컴파일이 이뤄지지 않는다.

하지만 타입스크립트는 타입 체크와 컴파일(자바스크립트로)이 별개로 이루어지기 때문에 컴파일이 가능하다.

### 런타임에는 타입 체크가 불가능하다.

타입스크립트의 타입들은 자바스크립트로 컴파일 되는 과정에서 제거되어 버린다.

```ts
interface Parent {
  witdh: number;
}
interface Children extends Parent {
  height: number;
}

function calc(shape: Children | Parent) {
  if (shape instanceof Children) {
    // Children은 형식만 참조하지만, 여기선 값으로 사용되고 있다.
    console.log(shape.heigth);
    // Error : Children 형식에 height 속성이 없습니다.
  }
}
```

이를 해결하기 위해서는 타입을 클래스로 만들거나, 타입에 타입 정보를 명시적으로 저장하는 방법이 있다.

### 타입 연산은 런타임에 영향을 주지 않는다.

타입 단언같은 타입스크립트 연산을 사용하더라도 이는 타입 체크 과정에서만 동작할 뿐 실제 자바스크립트 코드에서 변수의 타입에는 영향을 주지 않는다.

### 런타임 타입이 선언된 타입과 다를 수 있다.

네트워크 호출을 예로 들때, 타입 체크 과정에서는 네트워크의 응답 객체가 name 프로퍼티를 포함하고 있다고 선언했지만, 실제 서버 동작 과정에서 name 프로퍼티가 존재하지 않을 수도 있다.

```ts
// name은 서버에서 받아온 data 속에 포함되어 있다고 하자
function getName(name: "jung" | "wook") {
  switch (name) {
    case "jung":
      console.log(1);
      break;
    case "wook":
      console.log(2);
      break;
    default:
      console.log("엥");
  }
}
```

타입체크 관점에서 봤을 때 default case는 실행되지 못할 것 같지만, 실제 런타임 과정에서는 서버에서 name에 다른 문자열이 전달될 수도 있기 때문에 default case가 호출될 수 있다.

### 타입스크립트 타입으로는 함수를 오버로드 할 수 없다.

타입스크립트 함수 오버로딩 기능을 제공하지만 이것은 단지 타입 수준에서의 동작일 뿐이다.
타입스크립트는 타입체크와 런타임이 무관하기 때문에 C++이나 자바같은 언어처럼의 함수 오버로딩은 불가능하다.

> 타입스크립트로 여러개의 선언문을 작성할 수 는 있지만, 구현체는 단 하나뿐이다.

### 타입스크립트 타입은 런타임 성능에 영향을 주지 안흔다.

타입과 타입 연산자는 자바스크립트로 컴파일하는 과정에서 제거되기 때문에 런타임의 성능에 아무런 영향을 주지 못한다.

- 런타임 오버헤드가 없지만, 빌드 시점에서의 오버헤드는 발생한다.(하지만 상당히 빠른 컴파일을 보인다.)
