
최근 면접에서 DOM과 관련해서 리액트를 사용하는 이유에 대한 질문을 받았다.

스스로 만족스러운 답변을 하지 못한것 같아서 다시 정리해본다.

# SPA의 필요성, MPA에서 SPA로

리액트는 Single Page Application(이하 SPA)를 더 편하게 개발하게 해주는 라이브러리라고 알고 있다.

그럼 기존의 Multi Page Application(MPA)에서 SPA 패러다임을 선택하게 된 이유가 뭘까?

MPA는 다음과 같은 단점들이 있다.

1. 각 페이지 요청 시 마다 서버로부터 HTML, CSS, JS를 다시 요청받고 전체 페이지를 다시 렌더링 해야 한다.
2. 1번의 문제로 인해서 페이지 이동시 빈 화면이 보여지는 페이지 깜빡임이 발생한다.
3. 각 페이지 요청마다 서버에서 응답을 해줘야 하기 떄문에 대용량 트래픽 발생 시 서버의 부하가 커진다.

# SPA

이러한 단점들을 극복하기 위해서 SPA 패러다임이 탄생했다.

SPA는 초기 로딩 시에 HTML, CSS, JS를 하나만 로딩하고, 페이지 전환 시에 자바스크립트를 이용하여 동적으로 페이지를 업데이트하는 방식을 사용한다. 브라우저가 JS를 이용해서 페이지의 변경사항이나 페이지 전환을 동적으로 처리하기 때문에 서버의 부하도 많이 적어졌다.

하지만 바닐라 자바스크립트로 SPA를 구현하게 되면 몇가지 불편함이 생긴다.

## DOM API

JS를 이용해 동적으로 페이지의 요소를 조작하기 위해선 브라우저의 DOM API를 이용해야 한다. DOM API를 이용해서 DOM을 조작하고 브라우저가 이를 감지하면 수정된 DOM에 맞게 리플로우와 리페인트가 실시된다.

이런 방식의 문제는 단시간에 많은 DOM의 조작이 일어날 때 발생한다.

```js
const buttonHandler = () => {
  const $ul = document.getElementById("list");

  for (let i = 0; i < 3000; i++) {
    $ul.innerHTML += `<li>${i}</li>`;
  }
};
```

이 핸들러는 버튼을 클릭하면 ul엘리먼트에 3000개의 li요소를 추가하는 코드다.

반복문 속을 살펴보면 `$ul.innerHTML`을 직접적으로 수정하기 때문에 3000번의 리플로우와 리페인트를 발생시킨다.

이를 해결하기 위해선 아래와 같은 방식을 사용할 수 있다.

```js
const buttonHandler = () => {
  const $ul = document.getElementById("list");
  let list = "";

  for (let i = 0; i < 3000; i++) {
    list += `<li>${i}</li>`;
  }
  $ul.innerHTML = list;
};
```

`list`라는 변수를 선언해서 반복문에서는 list만 수정하고, 반복문이 끝나고 `$ul.innerHTML`을 단 한번만 변경하도록 코드를 작성하면 DOM 변경은 단 한번만 발생하고, 리플로우와 리페인트가 한번씩만 발생하게 된다.

## Virtual DOM (가상 돔)

위와 같은 방식으로 DOM의 조작을 최소화 할 수는 있지만 이런 방식은 서비스가 커질수록 컨트롤해야 할 DOM의 조작이나 업데이트를 감당하기 벅찰 수 있다.

그래서 리액트는 이러한 불편함을 해결하기 위해서 실제 DOM에 접근하는 대신에 이를 추상화 시킨 객체인 Virtual DOM를 이용하는 방법을 도입했다.

Virtual DOM은 React Element라는 객체 값들로 이루어져 있다.

```js
function Component() {
  // 컴포넌트를 호출하면 React Element 객체를 리턴한다.
  return (
    <div id="login-box">
      <p>hello</p>
    </div>
  );
  // JSX가 트랜스파일링 되면 HTML요소가 반환되는 것이 아니라 React Element 객체를 리턴한다.
}
```

```json
//React Element
//DOM에 반영되어야 할 요소들에 대한 정보를 담은 객체
{
  "type":"div",
  "key":null,
  "ref":null,
  "props":{
    "id":"login-box",
    "children" : {
      "type": "p",
      //...
    }
    //...
  }
}
```

리액트가 실행되면 리액트는 컴포넌트들을 호출해서 React Element들을 얻고, 이를 모아서 가상 돔을 만들어서 유지한다.

리액트는 앱에 변경사항이 발생하면 리액트는 우선 가상 돔에 변경사항을 적용하고, 실제 돔에 변경사항을 한번에 적용함으로서 DOM의 직접적인 조작을 최소화 하는 방식을 적용하고 있다.

### 리액트의 리렌더링 과정

컴포넌트의 상태가 변경되어서 리렌더링이 발생했을 때 리액트는 다음과 같은 방식으로 돔을 업데이트한다.

1. 페이지에 업데이트가 발생하면 (상태(props)변경, 페이지 이동, 이벤트 호출 등) 리액트는 컴포넌트를 재호출해서 새로운 가상 DOM을 생성한다.
2. 이전의 가상 DOM과 새로운 가상 DOM을 비교해서 차이점을 계산한다.
3. 변경된 차이점을 모아서 실제 DOM에 한번에 업데이트 한다.
4. 업데이트 된 DOM을 기반으로 다시 reflow와 repaint가 발생한다.

---

# 정리

이렇게 리액트는 빠른 업데이트를 보장하기 위해 내부적으로 가상 돔을 적용하여 DOM 조작의 횟수를 최소화 시켜 성능을 향상시킨다.

물론 이 뿐만 아니라 리액트는 다른 장점들도 포함하고 있다.

- 컴포넌트 아키텍처를 적용해서 코드의 재사용성과 가독성을 끌어올렸다.
- 상위 컴포넌트에서 하위 컴포넌트로의 단방향 데이터 흐름을 통해 데이터의 흐름을 유추하기 쉽다.
- JSX를 이용하여 새로운 요소를 추가할 때 마크업 언어처럼 작성할 수 있다.

---

# 여담

React가 왜 Vitual DOM을 사용하는지, Virtual DOM의 역할이 뭔지 이해하는데 도움이 되었다.

이제 누군가 나에게 왜 리액트를 사용하고 있냐 묻는다면 "SPA를 구현할 때 리액트가 내부적으로 가상 돔을 이용해 DOM 조작 횟수를 최소화하여 성능을 향상을 적용하고 있어 DOM조작 성능 개선을 덜 신경써도 되고, 컴포넌트 아키텍처를 채택하여 코드 유지보수가 좋기 떄문에 사용하고 있습니다." 정도로 대답할 수 있을것 같다.
